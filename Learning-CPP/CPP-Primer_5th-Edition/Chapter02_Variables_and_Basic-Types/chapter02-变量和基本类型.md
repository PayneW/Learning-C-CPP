# 第 2 章 ——  Variables and Basic Types  变量和基本类型


## 生词
- **integral ['ɪntɪgr(ə)l] --n.[数]积分；完整  --adj.完整的，完备的，整体的** 
    + --> integral equation 积分方程
    + --> integral method 积分法
    + --> integral structure 整体结构
    + --> definite integral 定积分
    + --> integral solution 整数解
- **arithmetic [ə'rɪθmətɪk] --n.算术，计算**
    + --> arithmetic had never been her strong point. 计算从来不是他的强项。

---------


## 前置知识:
- 1byte(字节) = 8 bit(比特/位)
- 1 word(字) = 4/8 byte(字节) = 32/64 bite(比特)

- **Note: C/C++ 中 string 与 char 的区别**
    + 在 C 语言中:
        - `char` 是定义一个字符，存储一个字符，占一个字节(byte)。
        - `string` 是定义一个字符串，存储的是一段如 "abcd" 的数据，而且最后还有一个
          结束符 "\0"; 
    + 在 C++ 中: 
        - `char` 是基本的字符类型，一个 `char` 的空间应确保可以存放机器基本字符集中任意
          字符对应的数字值。也就是说，一个 char 的大小和一个机器字节一样。

---------


## 2.1 Primitive Built-in Types (基本内置类型）
> **2.1.1 算术类型**
- 算术类型分为 2 类:
    + 整型 (integral type)


- *内置类型的机器实现*
    + **计算机以比特序列存储数据，每个比特(bit) 非 0 即 1**，例如:
        - 000110110111100010110010000111011...
    + 大多数计算机以 2 的整数次幂个比特(bit) 作为块来处理内存，可寻址的最小内存块称为 
      "字节 (byte)"，存储的基本单元称为 "字(word)", 它通常由几个字节组成。在 C++ 语言
      中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由 8bit(比特) 构成，
      字则由 32 或 64 比特构成，也就是 4 或 8 字节(byte).
    + 大多数计算机将内存中的每个 字节(byte) 与 一个数字 (被称为 "地址 (address)") 关联
      起来，在 1(byte)字节 为 8(bit)比特、字为 32(bit)比特的机器上，我们可以看到一个字
      的内存区域如下所示:
      |-----|
      |:---:|
      |736424|
      |736425|
      |736426|
      |736427|

      |-----|-----|-----|-----|-----|-----|-----|-----|
      |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
      |  0  |  0  |  1  |  1  |  1  |  0  |  1  |  1 |
      |  0  |  0  |  0  |  1  |  1  |  0  |  1  |  1 |
      |  0  |  1  |  1  |  1  |  0  |  0  |  0  |  1 |
      |  0  |  1  |  1  |  0  |  0  |  1  |  0  |  0 |
      第一个表格是字节的地址，下面表格是字节中 8 比特的具体内容。
    + 我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，例如，我们可能会说地址
      736424 的那个字或者地址 736427 的那个字节。为了赋予内存中某个地址明确的含义，必
      须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特
      的内容。


## 2.2 Variables (变量)


## 2.3 Compound Types (复合类型)
> C++ 的复合类型有哪些？ A: 引用、指针 和 数组。
> 复合类型 (compound type): 是指基于其他类型定义的类型。
- 一条简单的声明语句更通用的描述是: 一条声明语句由一个**基本数据类型(base type)** 和紧随
  其后的一个**声明符(declarator)**列表组成。每个声明符命名了一个变量并指定该变量为与基本
  数据类型有关的某种类型。(Tip: 声明符不就是变量名吗？变量名不应该说是 '标识符'?)
- 目前为止，我们接触的声明语句中，声明符其实是变量名，此时变量的类型也就是声明的基本数据类型。
  其实还可能有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。

> **2.3.1 引用**
- 引用(reference) 为对象起了另外一个名字，引用类型引用(refers to) 另外一个类型。通过将
  声明符写成 `&d` 的形式来定义引用类型，其中 d 是声明的变量名:
  ```cpp
    // - 定义一个类型为 int 的变量 ival, 并初始化值为 1024
    int ival = 1024;
    // - refVal 指向 ival (是 ival 的另一个名字)
    int &refVal = ival;
    // - 报错，引用必须初始化
    // int &refVal2;
  ```
- 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值
  绑定(bind) 在一起，而不是把初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直
  绑定在一起，因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。引用即别名。 

> **2.3.2 指针**
- 指针(pointer) 是 "指向(point to)" 另外一种类型的复合类型。与引用类似，指针也实现了对
  其他对象的间接引用。然而指针与引用相比又有不同点:
    + 1、指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向
      几个不同的对象。
    + 2、指针无须在定义时赋初始值。和其他内置类型一样，在块作用域内定义的指针如果没有初始化
      ，也将拥有一个不确定的值。
- 警告(Warning): 指针通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而备受
  折磨。
- 定义指针的方法是将声明符写成 `*d` 的形式，其中 d 是变量名。如果一条语句中定义了几个指针
  变量，每个变量前面都必须有符号 `*`:
  ```cpp
    // - 声明 2 个类型为 int 的指针 ip1 和 ip2 
    // - ip1, ip2 都是指向 int 型对象的指针
    int *ip1, *ip2; 
    // - 声明一个变量名为 dp 类型 
    double dp, *dp2;
  ```         



## 2.4 const Qualifier (const 限定符)


## 2.5 Dealing with Types (处理类型)


## 2.6 Defining Our Own Data Structures (自定义数据结构) 


## Chapter Summary (小结)


## Defined Terms (术语表)
# 第 2 章 ——  Variables and Basic Types  变量和基本类型


## 生词
- **arithmetic [ə'rɪθmətɪk] --n.算术，计算**
    + --> arithmetic had never been her strong point. 计算从来不是他的强项。
- **integral ['ɪntɪgr(ə)l] --n.[数]积分；完整  --adj.完整的，完备的，整体的** 
    + --> integral equation 积分方程
    + --> integral method 积分法
    + --> integral structure 整体结构
    + --> definite integral 定积分
    + --> integral solution 整数解
- **sign [saɪn] --n.符号，记号**  
---------



## 前置知识:
- 1byte(字节) = 8 bit(比特/位)
- 1 word(字) = 4/8 byte(字节) = 32/64 bite(比特)

- **Note: C/C++ 中 string 与 char 的区别**
    + 在 C 语言中:
        - `char` 是定义一个字符，存储一个字符，占一个字节(byte)。
        - `string` 是定义一个字符串，存储的是一段如 "abcd" 的数据，而且最后还有一个
          结束符 "\0"; 
    + 在 C++ 中: 
        - `char` 是基本的字符类型，一个 `char` 的空间应确保可以存放机器基本字符集中任意
          字符对应的数字值。也就是说，一个 char 的大小和一个机器字节一样。

---------


## 2.1 Primitive Built-in Types (基本内置类型）
> C++ 定义了一套包括 **算术类型 (arithmetic type)** 和 **空类型 (void)** 在内的基本
  数据类型。其中算术类型包含了: **字符、整型数、布尔值 和 浮点数**。空类型不对应具体的值，
  仅用于一些特殊的场合；例如最常见的是，当函数不返回任何值时使用空类型作为返回值。
#### **2.1.1 算术类型**
- 算术类型分为 2 类:
    + 整型 (integral type): 包括字符(char) 和 布尔类型(bool) 在内。
    + 浮点型。
- 算术类型的尺寸 (即该类型数据所占的比特(bit)数) 在不同的机器上有所差别。表 2.1 列出了
  C++ 标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。某一类型所占的比特数
  不同，它所能表示的数据范围也不一样。
- 下表 2.1: C++ 算术类型  
- |-类型-|-含义-|-最小尺寸-|
  |:---|:---|:---|
  |  bool      |  布尔类型     |  未定义  |
  |  char      |  字符         |  8 位 (bit/比特)  |
  |  wchar_t   |  宽字符       |  16 位  |
  |  char16_t  |  Unicode 字符 |  16 位  |
  |  char32_t  |  Unicode 字符 |  32 位  |
  |  short     |  短类型        |  16 位  |
  |  int       |  整型          | 16 位   |
  |  long      |  长整型        |  32 位  |
  |  long long |  长整型        |  64 位  |
  |  float     |  单精度浮点数   |  6 位(bit) 有效数字  |
  |  double    |  双精度浮点数   |  10 位有效数字  |
  | long double|  扩展精度浮点数  |  10 位有效数字  |
- 布尔类型 (bool) 的取值是真 (true) 或者 假 (false).
- C++ 提供了几种字符类型，其中多数支持国际化。基本的字符类型是 char，一个 char 的空间应
  确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 char 的大小和一个机器
  字节一样。
- 其他字符类型用于扩展字符集，如 wchar_t、char16_t、char32_t。 wchar_t 类型用于确保
  可以存放机器最大扩展字符集中的任意一个字符，类型 char16_t 和 char32_t 则为 Unicode
  字符集服务 (Unicode 是用于表示所有自然语言中字符的标准。) 
- *内置类型的机器实现*
    + **计算机以比特序列存储数据，每个比特(bit) 非 0 即 1**，例如:
        - 000110110111100010110010000111011...
    + 大多数计算机以 2 的整数次幂个比特(bit) 作为块来处理内存，可寻址的最小内存块称为 
      "字节 (byte)"，存储的基本单元称为 "字(word)", 它通常由几个字节组成。在 C++ 语言
      中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由 8bit(比特) 构成，
      字则由 32 或 64 比特构成，也就是 4 或 8 字节(byte).
    + 大多数计算机将内存中的每个 字节(byte) 与 一个数字 (被称为 "地址 (address)") 关联
      起来，在 1(byte)字节 为 8(bit)比特、字为 32(bit)比特的机器上，我们可以看到一个字
      的内存区域如下所示:
    + |-----|
      |:---:|
      |736424|
      |736425|
      |736426|
      |736427|
    + |-----|-----|-----|-----|-----|-----|-----|-----|
      |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
      |  0  |  0  |  1  |  1  |  1  |  0  |  1  |  1 |
      |  0  |  0  |  0  |  1  |  1  |  0  |  1  |  1 |
      |  0  |  1  |  1  |  1  |  0  |  0  |  0  |  1 |
      |  0  |  1  |  1  |  0  |  0  |  1  |  0  |  0 |
    + 第一个表格是字节的地址，下面表格是字节中 8 比特的具体内容。
    + 我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，例如，我们可能会说地址
      736424 的那个字或者地址 736427 的那个字节。为了赋予内存中某个地址明确的含义，必
      须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特
      的内容。
- 通常，float 以 1 个字 (32 bit)来表示，double 以 2 个字(64 bit)来表示，long double
  以 3 或 4 个字(96 或 128 比特[bit])来表示。一般来说，类型 float 和 double 分别有 
  7 和 16 个有效为； 类型 long double 则常常被用于有特殊浮点需求的硬件，它的具体实现不同，
  精度也各不相同。
> **带符号类型 和 无符号类型**
- 除去 布尔型 和 扩展的字符型之外， 其他整型可以划分为 **带符号(`signed`)的 和 无符号**
  **(`unsigned`)的** 2 种。 
    + 带符号类型可以表示**正数、负数、或 0**；
    + 无符号类型仅能表示**大于等 0 的值**。
- **`int、short、long 和 long long`** 都是带符号类型，通过在类型前面添加 **`unsigned`**
  就可以得到无符号类型，例如:`unsigned long`。类型 unsigned int 可以缩写为 `unsigned`.
- Q: 那么 `float double` 也是带符号类型吧？  
- 与其他整型不同，字符型被划分为 3 种: **`char、signed char 和 unsigned char`**。需要
  特别注意的是: 类型 char 和 类型 `signed char` 并不一样。尽管字符型有 3 种，但是字符的
  表现形式却只有 2 种: 带符号的 和 无符号的。类型 `char` 实际上会表现为上述 2 种形式中的
  一种，具体是哪种由编译器决定。 
- 无符号类型中所有比特都用来存储值，例如， 8 比特的 `unsigned char` 可以表示 0 到 255 
  区间内的值。
> **建议 (Advice): 如何选择类型？**
- 和 C 语言一样，C++ 的设计原则之一也是尽可能的接近硬件。C++ 的算术类型必须满足各种硬件
  特性，所以它们常常显得繁杂而令人不知所措。以下是选择类型的一些经验准则:
- 1、当明确知晓数值不可能为负时，选用无符号类型。
- 2、使用 `int` 执行整数运算。如果你的数值超过了 int 的表示范围，选用 long long。
- 3、在算术表达式中不要使用 char 或 bool，只有在存放字符或布尔值时才使用它们。如果你需要
  使用一个不大的整数，那么明确指定它的类型是 signed char 或者 unsigned char。
- 4、执行浮点运算选用 double， 这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数
  的计算代价相差无几。
    + [float 类型和 double 类型整理](https://blog.csdn.net/sinat_19447667/article/details/55224033);
    + float 在内存中的存储遵循 IEEE 754 标准。在 C/C++ 中，float 类型占 4 个字节即
      32 位，这32位分成 3 部分:
        - (1) 符号位: 转化成二进制后，第 31 位。0 代表正数，1 代表负数。
        - (2) 阶码: 30 - 23 位，转化成规格化的二进制之后与 127 之和。
        - (3) 尾数: 22 - 0 位。
        - |符号位|阶码|尾数|
          |:---|:---|:---|
          |1 bit| 8bit | 22 bit | 
          | 31 |  30 - 23 | 22 - 0|

#### **2.1.2 类型转换**
- 类型转换就是将一种给定的类型转换 (convert) 为另一种相关类型。
- 当给某种类型的对象强制赋予了另一种类型的值时，到底会发生什么: 看下面的代码
  ```cpp
    bool b = 42;
    // - 当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为 0 则结果
    //   是 false, 否则结果为 true
    std::cout << "b: " << b << std::endl;   // b: true

    // - 当我们把一个布尔值赋值给非布尔值时，初始值为 false 则结果为 0
    //   ，初始值为 true 则结果为 1.
    int i = b;
    std::cout << "i first:" << i << std::endl;  // i first:1

    i = 3.14;   // - i 的值为 3
    // i:3
    std::cout << "i:" << i << std::endl;

    double pi = i;  // - pi 的值是 3.0
    // - 当把一个整数值赋值给浮点类型时，小数部分记为 0。如果该整数所占的空间
    //   超过了浮点类型的容量，精度可能有损失。
    std::cout << "double pi:" << i << std::endl;

    // - 当我们赋值给无符号类型一个超出它表示范围的值时，结果是 "初始值对无符号
    //   类型表示数值总数取模后的余数。" (Q: 如何取模？)
    // - 例如: 8 bit 大小的 unsigned char 可以表示为 0 - 255 区间的值，如果
    //   我们赋值了一个区间外的值，则实际的结果是该值对 256 取模后所得的余数。因
    //   此，把 -1 赋给 8 比特大小的 unsigned char 所得到的结果是 255.
    unsigned char c = -1;
    std::cout << "unsigned char c:" << c << std::endl;

    signed char c2 = 256;
    std::cout << "signed char c2:" << c2 << std::endl;
  ```
> **含有无符号类型的表达式**
- 把负数 转换成 无符号数 类似于直接给无符号数赋一个负数，结果等于这个负数加上无符号数的模。
  ```cpp
    unsigned u = 10;
    int i = -42;
    // - 2 个(负)整数相加得到了期望的结果。
    std::cout << i + i << std::endl;
    // - 如果 int 占 32 为，输入 4294967264
    std::cout << u + i << std::endl;

    // - 当从无符号数 中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是
    //   一个负数:
    unsigned u1 = 42, u2 = 10;
    std::cout << u1 - ul << std::endl;  // - 正确输出 42
    std::cout << ur - u1 << std::endl;  // - 正确: 不过结果是取模后的值 
  ```
- Note: 切勿混用带符号类型和无符号类型
    + 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是
      因为带符号数会自动地转换成无符号数。

#### 2.1.3 字面值常量
> 一个形如 42 的值被称为 **字面值常量 (literal)**，这样的值一望而知。每个字面值常量都
  对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

> **整型和浮点型字面值**
- 我们用 10/8/16进制来表述数值 20:
    + 十进制: 20
    + 八进制: 024
    + 十六进制: 0x14
- 整型字面量具体的数据类型由它的“值”和”符号“决定。默认情况下，10进制字面值是带符号数，8进制
  和 16进制既可能是带符号的也可能是无符号的。    

> **字符和字符串字面值**
- 由单引号('')括起来的一个字符称为 char 类型字面值。
- 由双引号("")括起来的零个或多个字符则构成字符串型字面值。
  ```cpp
    #include <string>
    // - 字符字面值
    char aa = 'a';
    std::cout << "aa:" << aa << std::endl;  // aa:a

    // - 字符串字面值
    std::string str = "Hello World!";
    // string str:Hello World!
    std::cout << "string str:" << str << std::endl;
  ```
- 字符串字面值的类型实际上是由**常量字符**构成的**数组(array)**，该类型将在 3.5.4 节 
  (P109) 页介绍。编译器在每个字符串的结尾处添加一个空字符(`\0`)，因此，字符串字面值的
  实际长度要比它的内容多 1.
- 例如: 字面值 'A' 表示的是单独的字符 A, 而 字符串 "A" 则代表了一个字符的数组，该数组包含
  2 个字符: 一个是字母 A、另一个是空字符。
  ```cpp
    // - 分多行书写的字符串字面值
    std::cout << "a really, really long string literal "
                << "that span two lines" << std::endl;
  ```  

> **转义序列**
- 有 2 类字符程序员不能直接使用: 
    + 1、是 **不可打印 (nonprintable)**的字符,如退格或其他控制字符，因为它们没有可视
      的图符；
    + 2、是在 C++ 语言中有特殊含义的字符 (单引号、双引号、问号、反斜线)。
- 在这些情况系需要用到 **转义序列 (escape sequence)**, 转义序列均以反反斜线作为开始，
  C++ 语言规定的转义序列包括:
  
  |名称|对应转义序列|
  |:--|:--|
  |换行符|`\n`|   
  |反斜线|`\\`|      
  |回车符|`\r`| 
  |问号|`\?`| 
  |双引号|`\"`|   
  |单引号|`\'`|       
  |纵向制表符|`\v`|      
  |横向制表符|`\t`|      
  |退格符|`\b`|   
  |进纸符|`\f`|   
  |报警(响铃)符|`\a`|   
- 在程序中上述转义序列被当作一个字符使用:
  ```cpp
    std::cout << '\n'       // - 转到新的一行
    std::cout << "\tHi!\n"; // - 输出一个制表符，输入 "Hi!"，转到新一行 
  ```  
> **指定字面值的类型**
- 通过添加如表 2.2 中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。
  ```cpp
    L'a'    // - 宽字符型字面值，类型是 wchat_t;
    u8"hi!" // - utf-8 字符串字面值 (utf-8 用 8 位编码一个 Unicode 字符)
    42UL    // - 无符号整型字面值，类型是 unsigned long long
    1E-3F   // - 单精度浮点值字面值，类型是 float
    3.14159L // - 扩展精度浮点型字面值，类型是 long long
  ```
- 表 2.2: 指定字面值的类型
    + 字符和字符串字面值

      |前缀|含义|类型|
      |:---|:---|:---|
      | u | Unicode 16 字符| char16_t|
      | U | Unicode 32 字符| char32_t |
      | L | 宽字符| wchar_t |
      | u8| UTF-8 (仅用于字符串字面常量) | char |
    + 整型字面值

      |后缀|最小匹配类型|
      |:---|:---|
      |u or U| unsigned |
      |l or L| long |
      |ll or LL| long long |
    + 浮点型字面值

      |后缀|类型|  
      |:---|:---|  
      |f 或 F| float|  
      |l 或 L| long double|  

> **布尔字面值和指针字面值**  
- `true` 和 `false` 是布尔类型的字面值: 
  ```cpp
    bool test = false;
  ```
- `nullptr` 是指针字面值， 2.3.2 节 (P47) 将由更多关于指针和指针字面值的介绍。  

## 2.2 Variables (变量)
#### 2.2.1 变量定义
- 变量定义的基本形式是: 首先是 **类型说明符 (type specifier)**，随后紧跟由一个或多个
  变量名组成的列表，其中多个变量名时以逗号分隔，最后以分号结束。列表中每个变量名的类型都由
  类型说明符指定，定义时还可以为一个或多个变量附初始值：
  ```cpp
    // - sum、value、unites_sold 都是 int 类型；sum 和 unites_sold 初始值为 0
    int sum = 0, value, unites_sold = 0;
    // - item 的类型是 Sales_item (参见 1.5.1 节， Page17)
    Sales_item item;
    // - string 是一种库类型，表示一个可变长的字符序列
    // - string 像 iostream 一样也是在命名空间 std(standard library) 中定义的，
    //   我们将在第 3 章中对 string 类型做更详细的介绍。目前了解 string 是一种表示
    //   可变长度字符序列的数据类型就可以了。
    std::string book("0-201-78345-x");  // - book 通过一个 string 字面值初始化
  ```
> **初始值**
- 当对象在创建时获得了一个特定的值，我们说这个对象被 **初始化(initialized)**了。用于初始
  化变量的值可以是任意复杂的表达式。
  ```cpp
    // - 正确: price 变量先被定义并赋值，随后被用于初始化 discount
    double price = 109.99, discount = price * 0.16;
    // - 正确: 调用函数 applyDiscount，然后用函数的返回值初始化 salePrice
    double salePrice = applyDiscount(price, discount);
  ```
- C++ 中初始化是一个异常复杂的问题，我们也将反复讨论这个问题。很多程序员对于用等号(=) 来
  初始化变量的方式倍感困惑，这种方式容易让人以为初始化是赋值的一种。
  **事实上在 C++ 语言中，初始化和赋值是 2 个完全不同的操作。** 然而在很多编程语言中 2 者 
  的区别几乎可以忽略不计，即使在 C++ 语言中有时这种区别也无关紧要，所以人们特别容易把 2 者
  混为一谈。需要强调的是，这个概念至关重要，我们也将在后面不止一次提及这一点。
- **Warning: 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把**
  **对象的当前值擦除，而以一个新值来代替。**    

> **列表初始化**
- C++ 语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。例如想要定义一个名
  为 units_sold 的 int 变量并初始化为 0， 以下的 4 条语句都可以做到这一点:
  ```cpp
    int units_sold = 0;
    int units_sold = {0};
    int units_sold{0};
    int units_sold(0);
  ```
- 作为 C++11 新标准的一部分，用花括号来初始化变量得到了全面应用，出于 3.3.1 节(P88) 将要
  介绍的原因，这种初始化的形式被称为 **列表初始化 (list initialization)**。现在，无论
  是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。
- 当用于内置类型的变量时，这种初始化形式有一个重要特点: 如果我们使用列表初始化且初始值存在
  丢失信息的风险，则编译器将报错: 
  ```cpp
    long double ld = 3.1415926536;
    // - 错误: 转换未执行，因为存在丢失信息的危险
    int a{ld}, b = {ld};    // - Tip: 注意这里是使用的 {}
    int c(ld), d = ld;      // - 正确: 转换执行，且确定丢失了部分值。
  ```
- 使用 long double 的值初始化 int 变量时可能丢失数据，所以编译器拒绝了 a 和 b 的初始化
  请求。其中，至少 ld 的小数部分会丢失掉，而且 int 也可能存不下 ld 整数部分。
- 我们将在 3.2.1 节(P76) 和 3.3.1(P88) 对列表初始化做更多介绍。    

> **默认初始化**
- 如果定义变量时没有指定初始值，则变量被 **默认初始化(default initialized)**, 此时变量
  被赋予了 "默认值"。默认值到底是什么由变量类型决定，同时定义变量的位置也会对次有影响。
- 如果是内置类型的变量未被显示的初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被
  初始化为 0. 然而如 6.1.1 节(P185) 所示，一种例外情况是，定义在函数体内部的内置类型变量
  将**不被初始化(uninitialized)**。一个未被初始化的内置类型变量的值是未定义的 (参见: 
  2.1.2 节，P33)，如果试图拷贝或以其他形式访问次类值将引发错误。
- Note: 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示地
  初始化，则其值由类确定。
- Tip: 使用未初始化变量的值是一种错误的编程行为并且很难调试。建议初始化每一个内置类型的变量。    

#### 2.2.2 变量声明和定义的关系  
#### 2.2.3 标识符
#### 2.2.4 名字的作用域


## 2.3 Compound Types (复合类型)
> C++ 的复合类型有哪些？ A: 引用、指针 和 数组。
> 复合类型 (compound type): 是指基于其他类型定义的类型。
- 一条简单的声明语句更通用的描述是: 一条声明语句由一个**基本数据类型(base type)** 和紧随
  其后的一个**声明符(declarator)**列表组成。每个声明符命名了一个变量并指定该变量为与基本
  数据类型有关的某种类型。(Tip: 声明符不就是变量名吗？变量名不应该说是 '标识符'?)
- 目前为止，我们接触的声明语句中，声明符其实是变量名，此时变量的类型也就是声明的基本数据类型。
  其实还可能有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。

#### **2.3.1 引用**
- Note: C++11 中新增了一种引用: 所谓的 "右值引用 (rvalue reference)"，我们将在 13.6.1
  节 (第 471 页)
- 引用(reference) 为对象起了另外一个名字，引用类型引用(refers to) 另外一个类型。通过将
  声明符写成 `&d` 的形式来定义引用类型，其中 d 是声明的变量名:
  ```cpp
    // - 定义一个类型为 int 的变量 ival, 并初始化值为 1024
    int ival = 1024;
    // - 定义一个引用类型 refVal 指向 ival (是 ival 的另一个名字)
    int &refVal = ival;
    // - 报错，引用必须初始化
    // int &refVal2;
  ```
- 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值
  绑定(bind) 在一起，而不是把初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直
  绑定在一起，因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

> **引用即别名:**
- Note: 应用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。
- 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。
  ```cpp
    // - 把 2 赋值给了 refVal 指向的对象，此处既是赋值给了 ival.
    // - 为引用赋值实际上是把值赋值给了与引用绑定的对象。
    refVal = 2;
    
    // - 与 ii = ival 执行结果一样。
    // - 获取引用的值，实际上是获取了与引用绑定的对象的值。
    int ii = refVal;
    
    // - 以引用作为初始值，实际上是把引用绑定的对象作为初始值
    int &refVal3 = refVal;  // - 正确，&refVal3 指向 ival 的值 
    int i = refVal;         // - 正确，i 被初始化为 ival 的值
  ```
> **引用的定义**
- 允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号 `&` 开头:
  ```cpp
    int i = 1024, i2 = 2048;
    int &r = i, r2 = i2;
    int i3 = 1024, &ri = 13;
    int &r3 = i3, &r4 = i2;
  ```


#### **2.3.2 指针**
- 指针(pointer) 是 "指向(point to)" 另外一种类型的复合类型。与引用类似，指针也实现了对
  其他对象的间接引用。然而指针与引用相比又有不同点:
    + 1、指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向
      几个不同的对象。
    + 2、指针无须在定义时赋初始值。和其他内置类型一样，在块作用域内定义的指针如果没有初始化
      ，也将拥有一个不确定的值。
- 警告(Warning): 指针通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而备受
  折磨。
- 定义指针的方法是将声明符写成 `*d` 的形式，其中 d 是变量名。如果一条语句中定义了几个指针
  变量，每个变量前面都必须有符号 `*`:
  ```cpp
    // - 声明 2 个类型为 int 的指针 ip1 和 ip2 
    // - ip1, ip2 都是指向 int 类型对象的指针
    int *ip1, *ip2; 
    // - 声明一个类型为 double(双精浮点数) 变量名为 dp 的变量，和一个类型为 double 
    //   名为 ip2 的指针 
    double dp, *dp2;
  ```         



## 2.4 const Qualifier (const 限定符)


## 2.5 Dealing with Types (处理类型)


## 2.6 Defining Our Own Data Structures (自定义数据结构) 


## Chapter Summary (小结)


## Defined Terms (术语表)